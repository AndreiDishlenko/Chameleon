// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tax.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tax_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tax_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tax_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tax_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tax_2eproto;
namespace taxprro {
class Check;
struct CheckDefaultTypeInternal;
extern CheckDefaultTypeInternal _Check_default_instance_;
class CheckRequest;
struct CheckRequestDefaultTypeInternal;
extern CheckRequestDefaultTypeInternal _CheckRequest_default_instance_;
class CheckRequestId;
struct CheckRequestIdDefaultTypeInternal;
extern CheckRequestIdDefaultTypeInternal _CheckRequestId_default_instance_;
class CheckResponse;
struct CheckResponseDefaultTypeInternal;
extern CheckResponseDefaultTypeInternal _CheckResponse_default_instance_;
class RroInfoResponse;
struct RroInfoResponseDefaultTypeInternal;
extern RroInfoResponseDefaultTypeInternal _RroInfoResponse_default_instance_;
class RroInfoResponse_Operator;
struct RroInfoResponse_OperatorDefaultTypeInternal;
extern RroInfoResponse_OperatorDefaultTypeInternal _RroInfoResponse_Operator_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
}  // namespace taxprro
PROTOBUF_NAMESPACE_OPEN
template<> ::taxprro::Check* Arena::CreateMaybeMessage<::taxprro::Check>(Arena*);
template<> ::taxprro::CheckRequest* Arena::CreateMaybeMessage<::taxprro::CheckRequest>(Arena*);
template<> ::taxprro::CheckRequestId* Arena::CreateMaybeMessage<::taxprro::CheckRequestId>(Arena*);
template<> ::taxprro::CheckResponse* Arena::CreateMaybeMessage<::taxprro::CheckResponse>(Arena*);
template<> ::taxprro::RroInfoResponse* Arena::CreateMaybeMessage<::taxprro::RroInfoResponse>(Arena*);
template<> ::taxprro::RroInfoResponse_Operator* Arena::CreateMaybeMessage<::taxprro::RroInfoResponse_Operator>(Arena*);
template<> ::taxprro::StatusResponse* Arena::CreateMaybeMessage<::taxprro::StatusResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace taxprro {

enum Check_Type : int {
  Check_Type_UNKNOWN = 0,
  Check_Type_CHK = 1,
  Check_Type_ZREPORT = 2,
  Check_Type_SERVICECHK = 3,
  Check_Type_Check_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Check_Type_Check_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Check_Type_IsValid(int value);
constexpr Check_Type Check_Type_Type_MIN = Check_Type_UNKNOWN;
constexpr Check_Type Check_Type_Type_MAX = Check_Type_SERVICECHK;
constexpr int Check_Type_Type_ARRAYSIZE = Check_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Check_Type_descriptor();
template<typename T>
inline const std::string& Check_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Check_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Check_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Check_Type_descriptor(), enum_t_value);
}
inline bool Check_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Check_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Check_Type>(
    Check_Type_descriptor(), name, value);
}
enum CheckResponse_Status : int {
  CheckResponse_Status_UNKNOWN = 0,
  CheckResponse_Status_OK = 1,
  CheckResponse_Status_ERROR_VEREFY = -1,
  CheckResponse_Status_ERROR_CHECK = -2,
  CheckResponse_Status_ERROR_SAVE = -3,
  CheckResponse_Status_ERROR_UNKNOWN = -4,
  CheckResponse_Status_ERROR_TYPE = -5,
  CheckResponse_Status_ERROR_NOT_PREV_ZREPORT = -6,
  CheckResponse_Status_ERROR_XML = -7,
  CheckResponse_Status_ERROR_XML_DATE = -8,
  CheckResponse_Status_ERROR_XML_CHK = -9,
  CheckResponse_Status_ERROR_XML_ZREPORT = -10,
  CheckResponse_Status_ERROR_OFFLINE_168 = -11,
  CheckResponse_Status_ERROR_BAD_HASH_PREV = -12,
  CheckResponse_Status_ERROR_NOT_REGISTERED_RRO = -13,
  CheckResponse_Status_ERROR_NOT_REGISTERED_SIGNER = -14,
  CheckResponse_Status_ERROR_NOT_OPEN_SHIFT = -15,
  CheckResponse_Status_ERROR_OFFLINE_ID = -16,
  CheckResponse_Status_CheckResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CheckResponse_Status_CheckResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CheckResponse_Status_IsValid(int value);
constexpr CheckResponse_Status CheckResponse_Status_Status_MIN = CheckResponse_Status_ERROR_OFFLINE_ID;
constexpr CheckResponse_Status CheckResponse_Status_Status_MAX = CheckResponse_Status_OK;
constexpr int CheckResponse_Status_Status_ARRAYSIZE = CheckResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CheckResponse_Status_descriptor();
template<typename T>
inline const std::string& CheckResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CheckResponse_Status_descriptor(), enum_t_value);
}
inline bool CheckResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CheckResponse_Status>(
    CheckResponse_Status_descriptor(), name, value);
}
enum StatusResponse_Status : int {
  StatusResponse_Status_UNKNOWN = 0,
  StatusResponse_Status_OK = 1,
  StatusResponse_Status_ERROR_VEREFY = -1,
  StatusResponse_Status_ERROR_CHECK = -2,
  StatusResponse_Status_ERROR_UNKNOWN = -4,
  StatusResponse_Status_ERROR_NOT_REGISTERED_RRO = -13,
  StatusResponse_Status_ERROR_NOT_REGISTERED_SIGNER = -14,
  StatusResponse_Status_StatusResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StatusResponse_Status_StatusResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StatusResponse_Status_IsValid(int value);
constexpr StatusResponse_Status StatusResponse_Status_Status_MIN = StatusResponse_Status_ERROR_NOT_REGISTERED_SIGNER;
constexpr StatusResponse_Status StatusResponse_Status_Status_MAX = StatusResponse_Status_OK;
constexpr int StatusResponse_Status_Status_ARRAYSIZE = StatusResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusResponse_Status_descriptor();
template<typename T>
inline const std::string& StatusResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusResponse_Status_descriptor(), enum_t_value);
}
inline bool StatusResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatusResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusResponse_Status>(
    StatusResponse_Status_descriptor(), name, value);
}
enum RroInfoResponse_Status : int {
  RroInfoResponse_Status_UNKNOWN = 0,
  RroInfoResponse_Status_OK = 1,
  RroInfoResponse_Status_ERROR_VEREFY = -1,
  RroInfoResponse_Status_ERROR_CHECK = -2,
  RroInfoResponse_Status_ERROR_UNKNOWN = -4,
  RroInfoResponse_Status_ERROR_NOT_REGISTERED_RRO = -13,
  RroInfoResponse_Status_ERROR_NOT_REGISTERED_SIGNER = -14,
  RroInfoResponse_Status_RroInfoResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RroInfoResponse_Status_RroInfoResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RroInfoResponse_Status_IsValid(int value);
constexpr RroInfoResponse_Status RroInfoResponse_Status_Status_MIN = RroInfoResponse_Status_ERROR_NOT_REGISTERED_SIGNER;
constexpr RroInfoResponse_Status RroInfoResponse_Status_Status_MAX = RroInfoResponse_Status_OK;
constexpr int RroInfoResponse_Status_Status_ARRAYSIZE = RroInfoResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RroInfoResponse_Status_descriptor();
template<typename T>
inline const std::string& RroInfoResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RroInfoResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RroInfoResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RroInfoResponse_Status_descriptor(), enum_t_value);
}
inline bool RroInfoResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RroInfoResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RroInfoResponse_Status>(
    RroInfoResponse_Status_descriptor(), name, value);
}
// ===================================================================

class Check final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taxprro.Check) */ {
 public:
  inline Check() : Check(nullptr) {}
  ~Check() override;
  explicit constexpr Check(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Check(const Check& from);
  Check(Check&& from) noexcept
    : Check() {
    *this = ::std::move(from);
  }

  inline Check& operator=(const Check& from) {
    CopyFrom(from);
    return *this;
  }
  inline Check& operator=(Check&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Check& default_instance() {
    return *internal_default_instance();
  }
  static inline const Check* internal_default_instance() {
    return reinterpret_cast<const Check*>(
               &_Check_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Check& a, Check& b) {
    a.Swap(&b);
  }
  inline void Swap(Check* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Check* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Check* New() const final {
    return new Check();
  }

  Check* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Check>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Check& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Check& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Check* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "taxprro.Check";
  }
  protected:
  explicit Check(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Check_Type Type;
  static constexpr Type UNKNOWN =
    Check_Type_UNKNOWN;
  static constexpr Type CHK =
    Check_Type_CHK;
  static constexpr Type ZREPORT =
    Check_Type_ZREPORT;
  static constexpr Type SERVICECHK =
    Check_Type_SERVICECHK;
  static inline bool Type_IsValid(int value) {
    return Check_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Check_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Check_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Check_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Check_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Check_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Check_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRroFnFieldNumber = 1,
    kCheckSignFieldNumber = 3,
    kIdOfflineFieldNumber = 6,
    kIdCancelFieldNumber = 7,
    kDateTimeFieldNumber = 2,
    kLocalNumberFieldNumber = 4,
    kCheckTypeFieldNumber = 5,
  };
  // string rro_fn = 1;
  void clear_rro_fn();
  const std::string& rro_fn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rro_fn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rro_fn();
  PROTOBUF_MUST_USE_RESULT std::string* release_rro_fn();
  void set_allocated_rro_fn(std::string* rro_fn);
  private:
  const std::string& _internal_rro_fn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rro_fn(const std::string& value);
  std::string* _internal_mutable_rro_fn();
  public:

  // bytes check_sign = 3;
  void clear_check_sign();
  const std::string& check_sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_check_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_check_sign();
  PROTOBUF_MUST_USE_RESULT std::string* release_check_sign();
  void set_allocated_check_sign(std::string* check_sign);
  private:
  const std::string& _internal_check_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_check_sign(const std::string& value);
  std::string* _internal_mutable_check_sign();
  public:

  // string id_offline = 6;
  void clear_id_offline();
  const std::string& id_offline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id_offline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id_offline();
  PROTOBUF_MUST_USE_RESULT std::string* release_id_offline();
  void set_allocated_id_offline(std::string* id_offline);
  private:
  const std::string& _internal_id_offline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id_offline(const std::string& value);
  std::string* _internal_mutable_id_offline();
  public:

  // string id_cancel = 7;
  void clear_id_cancel();
  const std::string& id_cancel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id_cancel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id_cancel();
  PROTOBUF_MUST_USE_RESULT std::string* release_id_cancel();
  void set_allocated_id_cancel(std::string* id_cancel);
  private:
  const std::string& _internal_id_cancel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id_cancel(const std::string& value);
  std::string* _internal_mutable_id_cancel();
  public:

  // int64 date_time = 2;
  void clear_date_time();
  ::PROTOBUF_NAMESPACE_ID::int64 date_time() const;
  void set_date_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_date_time() const;
  void _internal_set_date_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 local_number = 4;
  void clear_local_number();
  ::PROTOBUF_NAMESPACE_ID::int32 local_number() const;
  void set_local_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_local_number() const;
  void _internal_set_local_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .taxprro.Check.Type check_type = 5;
  void clear_check_type();
  ::taxprro::Check_Type check_type() const;
  void set_check_type(::taxprro::Check_Type value);
  private:
  ::taxprro::Check_Type _internal_check_type() const;
  void _internal_set_check_type(::taxprro::Check_Type value);
  public:

  // @@protoc_insertion_point(class_scope:taxprro.Check)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rro_fn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr check_sign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_offline_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_cancel_;
  ::PROTOBUF_NAMESPACE_ID::int64 date_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 local_number_;
  int check_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tax_2eproto;
};
// -------------------------------------------------------------------

class CheckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taxprro.CheckRequest) */ {
 public:
  inline CheckRequest() : CheckRequest(nullptr) {}
  ~CheckRequest() override;
  explicit constexpr CheckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckRequest(const CheckRequest& from);
  CheckRequest(CheckRequest&& from) noexcept
    : CheckRequest() {
    *this = ::std::move(from);
  }

  inline CheckRequest& operator=(const CheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckRequest& operator=(CheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckRequest* internal_default_instance() {
    return reinterpret_cast<const CheckRequest*>(
               &_CheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CheckRequest& a, CheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckRequest* New() const final {
    return new CheckRequest();
  }

  CheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "taxprro.CheckRequest";
  }
  protected:
  explicit CheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRroFnSignFieldNumber = 3,
  };
  // bytes rro_fn_sign = 3;
  void clear_rro_fn_sign();
  const std::string& rro_fn_sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rro_fn_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rro_fn_sign();
  PROTOBUF_MUST_USE_RESULT std::string* release_rro_fn_sign();
  void set_allocated_rro_fn_sign(std::string* rro_fn_sign);
  private:
  const std::string& _internal_rro_fn_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rro_fn_sign(const std::string& value);
  std::string* _internal_mutable_rro_fn_sign();
  public:

  // @@protoc_insertion_point(class_scope:taxprro.CheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rro_fn_sign_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tax_2eproto;
};
// -------------------------------------------------------------------

class CheckRequestId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taxprro.CheckRequestId) */ {
 public:
  inline CheckRequestId() : CheckRequestId(nullptr) {}
  ~CheckRequestId() override;
  explicit constexpr CheckRequestId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckRequestId(const CheckRequestId& from);
  CheckRequestId(CheckRequestId&& from) noexcept
    : CheckRequestId() {
    *this = ::std::move(from);
  }

  inline CheckRequestId& operator=(const CheckRequestId& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckRequestId& operator=(CheckRequestId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckRequestId& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckRequestId* internal_default_instance() {
    return reinterpret_cast<const CheckRequestId*>(
               &_CheckRequestId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CheckRequestId& a, CheckRequestId& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckRequestId* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckRequestId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckRequestId* New() const final {
    return new CheckRequestId();
  }

  CheckRequestId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckRequestId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckRequestId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckRequestId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckRequestId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "taxprro.CheckRequestId";
  }
  protected:
  explicit CheckRequestId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRroFnSignFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes rro_fn_sign = 2;
  void clear_rro_fn_sign();
  const std::string& rro_fn_sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rro_fn_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rro_fn_sign();
  PROTOBUF_MUST_USE_RESULT std::string* release_rro_fn_sign();
  void set_allocated_rro_fn_sign(std::string* rro_fn_sign);
  private:
  const std::string& _internal_rro_fn_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rro_fn_sign(const std::string& value);
  std::string* _internal_mutable_rro_fn_sign();
  public:

  // @@protoc_insertion_point(class_scope:taxprro.CheckRequestId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rro_fn_sign_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tax_2eproto;
};
// -------------------------------------------------------------------

class CheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taxprro.CheckResponse) */ {
 public:
  inline CheckResponse() : CheckResponse(nullptr) {}
  ~CheckResponse() override;
  explicit constexpr CheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckResponse(const CheckResponse& from);
  CheckResponse(CheckResponse&& from) noexcept
    : CheckResponse() {
    *this = ::std::move(from);
  }

  inline CheckResponse& operator=(const CheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckResponse& operator=(CheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckResponse* internal_default_instance() {
    return reinterpret_cast<const CheckResponse*>(
               &_CheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CheckResponse& a, CheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckResponse* New() const final {
    return new CheckResponse();
  }

  CheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "taxprro.CheckResponse";
  }
  protected:
  explicit CheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CheckResponse_Status Status;
  static constexpr Status UNKNOWN =
    CheckResponse_Status_UNKNOWN;
  static constexpr Status OK =
    CheckResponse_Status_OK;
  static constexpr Status ERROR_VEREFY =
    CheckResponse_Status_ERROR_VEREFY;
  static constexpr Status ERROR_CHECK =
    CheckResponse_Status_ERROR_CHECK;
  static constexpr Status ERROR_SAVE =
    CheckResponse_Status_ERROR_SAVE;
  static constexpr Status ERROR_UNKNOWN =
    CheckResponse_Status_ERROR_UNKNOWN;
  static constexpr Status ERROR_TYPE =
    CheckResponse_Status_ERROR_TYPE;
  static constexpr Status ERROR_NOT_PREV_ZREPORT =
    CheckResponse_Status_ERROR_NOT_PREV_ZREPORT;
  static constexpr Status ERROR_XML =
    CheckResponse_Status_ERROR_XML;
  static constexpr Status ERROR_XML_DATE =
    CheckResponse_Status_ERROR_XML_DATE;
  static constexpr Status ERROR_XML_CHK =
    CheckResponse_Status_ERROR_XML_CHK;
  static constexpr Status ERROR_XML_ZREPORT =
    CheckResponse_Status_ERROR_XML_ZREPORT;
  static constexpr Status ERROR_OFFLINE_168 =
    CheckResponse_Status_ERROR_OFFLINE_168;
  static constexpr Status ERROR_BAD_HASH_PREV =
    CheckResponse_Status_ERROR_BAD_HASH_PREV;
  static constexpr Status ERROR_NOT_REGISTERED_RRO =
    CheckResponse_Status_ERROR_NOT_REGISTERED_RRO;
  static constexpr Status ERROR_NOT_REGISTERED_SIGNER =
    CheckResponse_Status_ERROR_NOT_REGISTERED_SIGNER;
  static constexpr Status ERROR_NOT_OPEN_SHIFT =
    CheckResponse_Status_ERROR_NOT_OPEN_SHIFT;
  static constexpr Status ERROR_OFFLINE_ID =
    CheckResponse_Status_ERROR_OFFLINE_ID;
  static inline bool Status_IsValid(int value) {
    return CheckResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    CheckResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    CheckResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    CheckResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return CheckResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return CheckResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return CheckResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIdSignFieldNumber = 3,
    kDataSignFieldNumber = 4,
    kErrorMessageFieldNumber = 5,
    kStatusFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes id_sign = 3;
  void clear_id_sign();
  const std::string& id_sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id_sign();
  PROTOBUF_MUST_USE_RESULT std::string* release_id_sign();
  void set_allocated_id_sign(std::string* id_sign);
  private:
  const std::string& _internal_id_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id_sign(const std::string& value);
  std::string* _internal_mutable_id_sign();
  public:

  // bytes data_sign = 4;
  void clear_data_sign();
  const std::string& data_sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_sign();
  PROTOBUF_MUST_USE_RESULT std::string* release_data_sign();
  void set_allocated_data_sign(std::string* data_sign);
  private:
  const std::string& _internal_data_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_sign(const std::string& value);
  std::string* _internal_mutable_data_sign();
  public:

  // string error_message = 5;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .taxprro.CheckResponse.Status status = 2;
  void clear_status();
  ::taxprro::CheckResponse_Status status() const;
  void set_status(::taxprro::CheckResponse_Status value);
  private:
  ::taxprro::CheckResponse_Status _internal_status() const;
  void _internal_set_status(::taxprro::CheckResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:taxprro.CheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_sign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_sign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tax_2eproto;
};
// -------------------------------------------------------------------

class StatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taxprro.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  explicit constexpr StatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const final {
    return new StatusResponse();
  }

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatusResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "taxprro.StatusResponse";
  }
  protected:
  explicit StatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StatusResponse_Status Status;
  static constexpr Status UNKNOWN =
    StatusResponse_Status_UNKNOWN;
  static constexpr Status OK =
    StatusResponse_Status_OK;
  static constexpr Status ERROR_VEREFY =
    StatusResponse_Status_ERROR_VEREFY;
  static constexpr Status ERROR_CHECK =
    StatusResponse_Status_ERROR_CHECK;
  static constexpr Status ERROR_UNKNOWN =
    StatusResponse_Status_ERROR_UNKNOWN;
  static constexpr Status ERROR_NOT_REGISTERED_RRO =
    StatusResponse_Status_ERROR_NOT_REGISTERED_RRO;
  static constexpr Status ERROR_NOT_REGISTERED_SIGNER =
    StatusResponse_Status_ERROR_NOT_REGISTERED_SIGNER;
  static inline bool Status_IsValid(int value) {
    return StatusResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    StatusResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    StatusResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    StatusResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return StatusResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return StatusResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return StatusResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLastSignerFieldNumber = 3,
    kErrorMessageFieldNumber = 5,
    kOpenShiftFieldNumber = 1,
    kOnlineFieldNumber = 2,
    kStatusFieldNumber = 4,
  };
  // string last_signer = 3;
  void clear_last_signer();
  const std::string& last_signer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_signer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_signer();
  PROTOBUF_MUST_USE_RESULT std::string* release_last_signer();
  void set_allocated_last_signer(std::string* last_signer);
  private:
  const std::string& _internal_last_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_signer(const std::string& value);
  std::string* _internal_mutable_last_signer();
  public:

  // string error_message = 5;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool open_shift = 1;
  void clear_open_shift();
  bool open_shift() const;
  void set_open_shift(bool value);
  private:
  bool _internal_open_shift() const;
  void _internal_set_open_shift(bool value);
  public:

  // bool online = 2;
  void clear_online();
  bool online() const;
  void set_online(bool value);
  private:
  bool _internal_online() const;
  void _internal_set_online(bool value);
  public:

  // .taxprro.StatusResponse.Status status = 4;
  void clear_status();
  ::taxprro::StatusResponse_Status status() const;
  void set_status(::taxprro::StatusResponse_Status value);
  private:
  ::taxprro::StatusResponse_Status _internal_status() const;
  void _internal_set_status(::taxprro::StatusResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:taxprro.StatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_signer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool open_shift_;
  bool online_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tax_2eproto;
};
// -------------------------------------------------------------------

class RroInfoResponse_Operator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taxprro.RroInfoResponse.Operator) */ {
 public:
  inline RroInfoResponse_Operator() : RroInfoResponse_Operator(nullptr) {}
  ~RroInfoResponse_Operator() override;
  explicit constexpr RroInfoResponse_Operator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RroInfoResponse_Operator(const RroInfoResponse_Operator& from);
  RroInfoResponse_Operator(RroInfoResponse_Operator&& from) noexcept
    : RroInfoResponse_Operator() {
    *this = ::std::move(from);
  }

  inline RroInfoResponse_Operator& operator=(const RroInfoResponse_Operator& from) {
    CopyFrom(from);
    return *this;
  }
  inline RroInfoResponse_Operator& operator=(RroInfoResponse_Operator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RroInfoResponse_Operator& default_instance() {
    return *internal_default_instance();
  }
  static inline const RroInfoResponse_Operator* internal_default_instance() {
    return reinterpret_cast<const RroInfoResponse_Operator*>(
               &_RroInfoResponse_Operator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RroInfoResponse_Operator& a, RroInfoResponse_Operator& b) {
    a.Swap(&b);
  }
  inline void Swap(RroInfoResponse_Operator* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RroInfoResponse_Operator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RroInfoResponse_Operator* New() const final {
    return new RroInfoResponse_Operator();
  }

  RroInfoResponse_Operator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RroInfoResponse_Operator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RroInfoResponse_Operator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RroInfoResponse_Operator& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RroInfoResponse_Operator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "taxprro.RroInfoResponse.Operator";
  }
  protected:
  explicit RroInfoResponse_Operator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialFieldNumber = 1,
    kIsnameFieldNumber = 4,
    kStatusFieldNumber = 2,
    kSeniorFieldNumber = 3,
  };
  // string serial = 1;
  void clear_serial();
  const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial();
  PROTOBUF_MUST_USE_RESULT std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // string isname = 4;
  void clear_isname();
  const std::string& isname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_isname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_isname();
  PROTOBUF_MUST_USE_RESULT std::string* release_isname();
  void set_allocated_isname(std::string* isname);
  private:
  const std::string& _internal_isname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_isname(const std::string& value);
  std::string* _internal_mutable_isname();
  public:

  // int32 status = 2;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool senior = 3;
  void clear_senior();
  bool senior() const;
  void set_senior(bool value);
  private:
  bool _internal_senior() const;
  void _internal_set_senior(bool value);
  public:

  // @@protoc_insertion_point(class_scope:taxprro.RroInfoResponse.Operator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr isname_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  bool senior_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tax_2eproto;
};
// -------------------------------------------------------------------

class RroInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taxprro.RroInfoResponse) */ {
 public:
  inline RroInfoResponse() : RroInfoResponse(nullptr) {}
  ~RroInfoResponse() override;
  explicit constexpr RroInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RroInfoResponse(const RroInfoResponse& from);
  RroInfoResponse(RroInfoResponse&& from) noexcept
    : RroInfoResponse() {
    *this = ::std::move(from);
  }

  inline RroInfoResponse& operator=(const RroInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RroInfoResponse& operator=(RroInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RroInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RroInfoResponse* internal_default_instance() {
    return reinterpret_cast<const RroInfoResponse*>(
               &_RroInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RroInfoResponse& a, RroInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RroInfoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RroInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RroInfoResponse* New() const final {
    return new RroInfoResponse();
  }

  RroInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RroInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RroInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RroInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RroInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "taxprro.RroInfoResponse";
  }
  protected:
  explicit RroInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RroInfoResponse_Operator Operator;

  typedef RroInfoResponse_Status Status;
  static constexpr Status UNKNOWN =
    RroInfoResponse_Status_UNKNOWN;
  static constexpr Status OK =
    RroInfoResponse_Status_OK;
  static constexpr Status ERROR_VEREFY =
    RroInfoResponse_Status_ERROR_VEREFY;
  static constexpr Status ERROR_CHECK =
    RroInfoResponse_Status_ERROR_CHECK;
  static constexpr Status ERROR_UNKNOWN =
    RroInfoResponse_Status_ERROR_UNKNOWN;
  static constexpr Status ERROR_NOT_REGISTERED_RRO =
    RroInfoResponse_Status_ERROR_NOT_REGISTERED_RRO;
  static constexpr Status ERROR_NOT_REGISTERED_SIGNER =
    RroInfoResponse_Status_ERROR_NOT_REGISTERED_SIGNER;
  static inline bool Status_IsValid(int value) {
    return RroInfoResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    RroInfoResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    RroInfoResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    RroInfoResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return RroInfoResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return RroInfoResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return RroInfoResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOperatorsFieldNumber = 13,
    kLastSignerFieldNumber = 5,
    kNameFieldNumber = 6,
    kNameToFieldNumber = 7,
    kAddrFieldNumber = 8,
    kPnFieldNumber = 12,
    kTinsFieldNumber = 14,
    kNamePayFieldNumber = 16,
    kStatusFieldNumber = 1,
    kStatusRroFieldNumber = 2,
    kOpenShiftFieldNumber = 3,
    kOnlineFieldNumber = 4,
    kSingleTaxFieldNumber = 9,
    kOfflineAllowedFieldNumber = 10,
    kAddNumFieldNumber = 11,
    kLnumFieldNumber = 15,
  };
  // repeated .taxprro.RroInfoResponse.Operator operators = 13;
  int operators_size() const;
  private:
  int _internal_operators_size() const;
  public:
  void clear_operators();
  ::taxprro::RroInfoResponse_Operator* mutable_operators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::taxprro::RroInfoResponse_Operator >*
      mutable_operators();
  private:
  const ::taxprro::RroInfoResponse_Operator& _internal_operators(int index) const;
  ::taxprro::RroInfoResponse_Operator* _internal_add_operators();
  public:
  const ::taxprro::RroInfoResponse_Operator& operators(int index) const;
  ::taxprro::RroInfoResponse_Operator* add_operators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::taxprro::RroInfoResponse_Operator >&
      operators() const;

  // string last_signer = 5;
  void clear_last_signer();
  const std::string& last_signer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_signer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_signer();
  PROTOBUF_MUST_USE_RESULT std::string* release_last_signer();
  void set_allocated_last_signer(std::string* last_signer);
  private:
  const std::string& _internal_last_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_signer(const std::string& value);
  std::string* _internal_mutable_last_signer();
  public:

  // string name = 6;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string name_to = 7;
  void clear_name_to();
  const std::string& name_to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name_to();
  PROTOBUF_MUST_USE_RESULT std::string* release_name_to();
  void set_allocated_name_to(std::string* name_to);
  private:
  const std::string& _internal_name_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_to(const std::string& value);
  std::string* _internal_mutable_name_to();
  public:

  // string addr = 8;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_MUST_USE_RESULT std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // string pn = 12;
  void clear_pn();
  const std::string& pn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pn();
  PROTOBUF_MUST_USE_RESULT std::string* release_pn();
  void set_allocated_pn(std::string* pn);
  private:
  const std::string& _internal_pn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pn(const std::string& value);
  std::string* _internal_mutable_pn();
  public:

  // string tins = 14;
  void clear_tins();
  const std::string& tins() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tins(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tins();
  PROTOBUF_MUST_USE_RESULT std::string* release_tins();
  void set_allocated_tins(std::string* tins);
  private:
  const std::string& _internal_tins() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tins(const std::string& value);
  std::string* _internal_mutable_tins();
  public:

  // string name_pay = 16;
  void clear_name_pay();
  const std::string& name_pay() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name_pay(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name_pay();
  PROTOBUF_MUST_USE_RESULT std::string* release_name_pay();
  void set_allocated_name_pay(std::string* name_pay);
  private:
  const std::string& _internal_name_pay() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_pay(const std::string& value);
  std::string* _internal_mutable_name_pay();
  public:

  // .taxprro.RroInfoResponse.Status status = 1;
  void clear_status();
  ::taxprro::RroInfoResponse_Status status() const;
  void set_status(::taxprro::RroInfoResponse_Status value);
  private:
  ::taxprro::RroInfoResponse_Status _internal_status() const;
  void _internal_set_status(::taxprro::RroInfoResponse_Status value);
  public:

  // int32 status_rro = 2;
  void clear_status_rro();
  ::PROTOBUF_NAMESPACE_ID::int32 status_rro() const;
  void set_status_rro(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status_rro() const;
  void _internal_set_status_rro(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool open_shift = 3;
  void clear_open_shift();
  bool open_shift() const;
  void set_open_shift(bool value);
  private:
  bool _internal_open_shift() const;
  void _internal_set_open_shift(bool value);
  public:

  // bool online = 4;
  void clear_online();
  bool online() const;
  void set_online(bool value);
  private:
  bool _internal_online() const;
  void _internal_set_online(bool value);
  public:

  // bool single_tax = 9;
  void clear_single_tax();
  bool single_tax() const;
  void set_single_tax(bool value);
  private:
  bool _internal_single_tax() const;
  void _internal_set_single_tax(bool value);
  public:

  // bool offline_allowed = 10;
  void clear_offline_allowed();
  bool offline_allowed() const;
  void set_offline_allowed(bool value);
  private:
  bool _internal_offline_allowed() const;
  void _internal_set_offline_allowed(bool value);
  public:

  // int32 add_num = 11;
  void clear_add_num();
  ::PROTOBUF_NAMESPACE_ID::int32 add_num() const;
  void set_add_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_add_num() const;
  void _internal_set_add_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 lnum = 15;
  void clear_lnum();
  ::PROTOBUF_NAMESPACE_ID::int32 lnum() const;
  void set_lnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lnum() const;
  void _internal_set_lnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:taxprro.RroInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::taxprro::RroInfoResponse_Operator > operators_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_signer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_to_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tins_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_pay_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_rro_;
  bool open_shift_;
  bool online_;
  bool single_tax_;
  bool offline_allowed_;
  ::PROTOBUF_NAMESPACE_ID::int32 add_num_;
  ::PROTOBUF_NAMESPACE_ID::int32 lnum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tax_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Check

// string rro_fn = 1;
inline void Check::clear_rro_fn() {
  rro_fn_.ClearToEmpty();
}
inline const std::string& Check::rro_fn() const {
  // @@protoc_insertion_point(field_get:taxprro.Check.rro_fn)
  return _internal_rro_fn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Check::set_rro_fn(ArgT0&& arg0, ArgT... args) {
 
 rro_fn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.Check.rro_fn)
}
inline std::string* Check::mutable_rro_fn() {
  std::string* _s = _internal_mutable_rro_fn();
  // @@protoc_insertion_point(field_mutable:taxprro.Check.rro_fn)
  return _s;
}
inline const std::string& Check::_internal_rro_fn() const {
  return rro_fn_.Get();
}
inline void Check::_internal_set_rro_fn(const std::string& value) {
  
  rro_fn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Check::_internal_mutable_rro_fn() {
  
  return rro_fn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Check::release_rro_fn() {
  // @@protoc_insertion_point(field_release:taxprro.Check.rro_fn)
  return rro_fn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Check::set_allocated_rro_fn(std::string* rro_fn) {
  if (rro_fn != nullptr) {
    
  } else {
    
  }
  rro_fn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rro_fn,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.Check.rro_fn)
}

// int64 date_time = 2;
inline void Check::clear_date_time() {
  date_time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Check::_internal_date_time() const {
  return date_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Check::date_time() const {
  // @@protoc_insertion_point(field_get:taxprro.Check.date_time)
  return _internal_date_time();
}
inline void Check::_internal_set_date_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  date_time_ = value;
}
inline void Check::set_date_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_date_time(value);
  // @@protoc_insertion_point(field_set:taxprro.Check.date_time)
}

// bytes check_sign = 3;
inline void Check::clear_check_sign() {
  check_sign_.ClearToEmpty();
}
inline const std::string& Check::check_sign() const {
  // @@protoc_insertion_point(field_get:taxprro.Check.check_sign)
  return _internal_check_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Check::set_check_sign(ArgT0&& arg0, ArgT... args) {
 
 check_sign_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.Check.check_sign)
}
inline std::string* Check::mutable_check_sign() {
  std::string* _s = _internal_mutable_check_sign();
  // @@protoc_insertion_point(field_mutable:taxprro.Check.check_sign)
  return _s;
}
inline const std::string& Check::_internal_check_sign() const {
  return check_sign_.Get();
}
inline void Check::_internal_set_check_sign(const std::string& value) {
  
  check_sign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Check::_internal_mutable_check_sign() {
  
  return check_sign_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Check::release_check_sign() {
  // @@protoc_insertion_point(field_release:taxprro.Check.check_sign)
  return check_sign_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Check::set_allocated_check_sign(std::string* check_sign) {
  if (check_sign != nullptr) {
    
  } else {
    
  }
  check_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), check_sign,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.Check.check_sign)
}

// int32 local_number = 4;
inline void Check::clear_local_number() {
  local_number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Check::_internal_local_number() const {
  return local_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Check::local_number() const {
  // @@protoc_insertion_point(field_get:taxprro.Check.local_number)
  return _internal_local_number();
}
inline void Check::_internal_set_local_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  local_number_ = value;
}
inline void Check::set_local_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_local_number(value);
  // @@protoc_insertion_point(field_set:taxprro.Check.local_number)
}

// .taxprro.Check.Type check_type = 5;
inline void Check::clear_check_type() {
  check_type_ = 0;
}
inline ::taxprro::Check_Type Check::_internal_check_type() const {
  return static_cast< ::taxprro::Check_Type >(check_type_);
}
inline ::taxprro::Check_Type Check::check_type() const {
  // @@protoc_insertion_point(field_get:taxprro.Check.check_type)
  return _internal_check_type();
}
inline void Check::_internal_set_check_type(::taxprro::Check_Type value) {
  
  check_type_ = value;
}
inline void Check::set_check_type(::taxprro::Check_Type value) {
  _internal_set_check_type(value);
  // @@protoc_insertion_point(field_set:taxprro.Check.check_type)
}

// string id_offline = 6;
inline void Check::clear_id_offline() {
  id_offline_.ClearToEmpty();
}
inline const std::string& Check::id_offline() const {
  // @@protoc_insertion_point(field_get:taxprro.Check.id_offline)
  return _internal_id_offline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Check::set_id_offline(ArgT0&& arg0, ArgT... args) {
 
 id_offline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.Check.id_offline)
}
inline std::string* Check::mutable_id_offline() {
  std::string* _s = _internal_mutable_id_offline();
  // @@protoc_insertion_point(field_mutable:taxprro.Check.id_offline)
  return _s;
}
inline const std::string& Check::_internal_id_offline() const {
  return id_offline_.Get();
}
inline void Check::_internal_set_id_offline(const std::string& value) {
  
  id_offline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Check::_internal_mutable_id_offline() {
  
  return id_offline_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Check::release_id_offline() {
  // @@protoc_insertion_point(field_release:taxprro.Check.id_offline)
  return id_offline_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Check::set_allocated_id_offline(std::string* id_offline) {
  if (id_offline != nullptr) {
    
  } else {
    
  }
  id_offline_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id_offline,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.Check.id_offline)
}

// string id_cancel = 7;
inline void Check::clear_id_cancel() {
  id_cancel_.ClearToEmpty();
}
inline const std::string& Check::id_cancel() const {
  // @@protoc_insertion_point(field_get:taxprro.Check.id_cancel)
  return _internal_id_cancel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Check::set_id_cancel(ArgT0&& arg0, ArgT... args) {
 
 id_cancel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.Check.id_cancel)
}
inline std::string* Check::mutable_id_cancel() {
  std::string* _s = _internal_mutable_id_cancel();
  // @@protoc_insertion_point(field_mutable:taxprro.Check.id_cancel)
  return _s;
}
inline const std::string& Check::_internal_id_cancel() const {
  return id_cancel_.Get();
}
inline void Check::_internal_set_id_cancel(const std::string& value) {
  
  id_cancel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Check::_internal_mutable_id_cancel() {
  
  return id_cancel_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Check::release_id_cancel() {
  // @@protoc_insertion_point(field_release:taxprro.Check.id_cancel)
  return id_cancel_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Check::set_allocated_id_cancel(std::string* id_cancel) {
  if (id_cancel != nullptr) {
    
  } else {
    
  }
  id_cancel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id_cancel,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.Check.id_cancel)
}

// -------------------------------------------------------------------

// CheckRequest

// bytes rro_fn_sign = 3;
inline void CheckRequest::clear_rro_fn_sign() {
  rro_fn_sign_.ClearToEmpty();
}
inline const std::string& CheckRequest::rro_fn_sign() const {
  // @@protoc_insertion_point(field_get:taxprro.CheckRequest.rro_fn_sign)
  return _internal_rro_fn_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckRequest::set_rro_fn_sign(ArgT0&& arg0, ArgT... args) {
 
 rro_fn_sign_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.CheckRequest.rro_fn_sign)
}
inline std::string* CheckRequest::mutable_rro_fn_sign() {
  std::string* _s = _internal_mutable_rro_fn_sign();
  // @@protoc_insertion_point(field_mutable:taxprro.CheckRequest.rro_fn_sign)
  return _s;
}
inline const std::string& CheckRequest::_internal_rro_fn_sign() const {
  return rro_fn_sign_.Get();
}
inline void CheckRequest::_internal_set_rro_fn_sign(const std::string& value) {
  
  rro_fn_sign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CheckRequest::_internal_mutable_rro_fn_sign() {
  
  return rro_fn_sign_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CheckRequest::release_rro_fn_sign() {
  // @@protoc_insertion_point(field_release:taxprro.CheckRequest.rro_fn_sign)
  return rro_fn_sign_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CheckRequest::set_allocated_rro_fn_sign(std::string* rro_fn_sign) {
  if (rro_fn_sign != nullptr) {
    
  } else {
    
  }
  rro_fn_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rro_fn_sign,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.CheckRequest.rro_fn_sign)
}

// -------------------------------------------------------------------

// CheckRequestId

// string id = 1;
inline void CheckRequestId::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CheckRequestId::id() const {
  // @@protoc_insertion_point(field_get:taxprro.CheckRequestId.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckRequestId::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.CheckRequestId.id)
}
inline std::string* CheckRequestId::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:taxprro.CheckRequestId.id)
  return _s;
}
inline const std::string& CheckRequestId::_internal_id() const {
  return id_.Get();
}
inline void CheckRequestId::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CheckRequestId::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CheckRequestId::release_id() {
  // @@protoc_insertion_point(field_release:taxprro.CheckRequestId.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CheckRequestId::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.CheckRequestId.id)
}

// bytes rro_fn_sign = 2;
inline void CheckRequestId::clear_rro_fn_sign() {
  rro_fn_sign_.ClearToEmpty();
}
inline const std::string& CheckRequestId::rro_fn_sign() const {
  // @@protoc_insertion_point(field_get:taxprro.CheckRequestId.rro_fn_sign)
  return _internal_rro_fn_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckRequestId::set_rro_fn_sign(ArgT0&& arg0, ArgT... args) {
 
 rro_fn_sign_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.CheckRequestId.rro_fn_sign)
}
inline std::string* CheckRequestId::mutable_rro_fn_sign() {
  std::string* _s = _internal_mutable_rro_fn_sign();
  // @@protoc_insertion_point(field_mutable:taxprro.CheckRequestId.rro_fn_sign)
  return _s;
}
inline const std::string& CheckRequestId::_internal_rro_fn_sign() const {
  return rro_fn_sign_.Get();
}
inline void CheckRequestId::_internal_set_rro_fn_sign(const std::string& value) {
  
  rro_fn_sign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CheckRequestId::_internal_mutable_rro_fn_sign() {
  
  return rro_fn_sign_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CheckRequestId::release_rro_fn_sign() {
  // @@protoc_insertion_point(field_release:taxprro.CheckRequestId.rro_fn_sign)
  return rro_fn_sign_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CheckRequestId::set_allocated_rro_fn_sign(std::string* rro_fn_sign) {
  if (rro_fn_sign != nullptr) {
    
  } else {
    
  }
  rro_fn_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rro_fn_sign,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.CheckRequestId.rro_fn_sign)
}

// -------------------------------------------------------------------

// CheckResponse

// string id = 1;
inline void CheckResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CheckResponse::id() const {
  // @@protoc_insertion_point(field_get:taxprro.CheckResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.CheckResponse.id)
}
inline std::string* CheckResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:taxprro.CheckResponse.id)
  return _s;
}
inline const std::string& CheckResponse::_internal_id() const {
  return id_.Get();
}
inline void CheckResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CheckResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CheckResponse::release_id() {
  // @@protoc_insertion_point(field_release:taxprro.CheckResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CheckResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.CheckResponse.id)
}

// .taxprro.CheckResponse.Status status = 2;
inline void CheckResponse::clear_status() {
  status_ = 0;
}
inline ::taxprro::CheckResponse_Status CheckResponse::_internal_status() const {
  return static_cast< ::taxprro::CheckResponse_Status >(status_);
}
inline ::taxprro::CheckResponse_Status CheckResponse::status() const {
  // @@protoc_insertion_point(field_get:taxprro.CheckResponse.status)
  return _internal_status();
}
inline void CheckResponse::_internal_set_status(::taxprro::CheckResponse_Status value) {
  
  status_ = value;
}
inline void CheckResponse::set_status(::taxprro::CheckResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:taxprro.CheckResponse.status)
}

// bytes id_sign = 3;
inline void CheckResponse::clear_id_sign() {
  id_sign_.ClearToEmpty();
}
inline const std::string& CheckResponse::id_sign() const {
  // @@protoc_insertion_point(field_get:taxprro.CheckResponse.id_sign)
  return _internal_id_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckResponse::set_id_sign(ArgT0&& arg0, ArgT... args) {
 
 id_sign_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.CheckResponse.id_sign)
}
inline std::string* CheckResponse::mutable_id_sign() {
  std::string* _s = _internal_mutable_id_sign();
  // @@protoc_insertion_point(field_mutable:taxprro.CheckResponse.id_sign)
  return _s;
}
inline const std::string& CheckResponse::_internal_id_sign() const {
  return id_sign_.Get();
}
inline void CheckResponse::_internal_set_id_sign(const std::string& value) {
  
  id_sign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CheckResponse::_internal_mutable_id_sign() {
  
  return id_sign_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CheckResponse::release_id_sign() {
  // @@protoc_insertion_point(field_release:taxprro.CheckResponse.id_sign)
  return id_sign_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CheckResponse::set_allocated_id_sign(std::string* id_sign) {
  if (id_sign != nullptr) {
    
  } else {
    
  }
  id_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id_sign,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.CheckResponse.id_sign)
}

// bytes data_sign = 4;
inline void CheckResponse::clear_data_sign() {
  data_sign_.ClearToEmpty();
}
inline const std::string& CheckResponse::data_sign() const {
  // @@protoc_insertion_point(field_get:taxprro.CheckResponse.data_sign)
  return _internal_data_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckResponse::set_data_sign(ArgT0&& arg0, ArgT... args) {
 
 data_sign_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.CheckResponse.data_sign)
}
inline std::string* CheckResponse::mutable_data_sign() {
  std::string* _s = _internal_mutable_data_sign();
  // @@protoc_insertion_point(field_mutable:taxprro.CheckResponse.data_sign)
  return _s;
}
inline const std::string& CheckResponse::_internal_data_sign() const {
  return data_sign_.Get();
}
inline void CheckResponse::_internal_set_data_sign(const std::string& value) {
  
  data_sign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CheckResponse::_internal_mutable_data_sign() {
  
  return data_sign_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CheckResponse::release_data_sign() {
  // @@protoc_insertion_point(field_release:taxprro.CheckResponse.data_sign)
  return data_sign_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CheckResponse::set_allocated_data_sign(std::string* data_sign) {
  if (data_sign != nullptr) {
    
  } else {
    
  }
  data_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_sign,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.CheckResponse.data_sign)
}

// string error_message = 5;
inline void CheckResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& CheckResponse::error_message() const {
  // @@protoc_insertion_point(field_get:taxprro.CheckResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.CheckResponse.error_message)
}
inline std::string* CheckResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:taxprro.CheckResponse.error_message)
  return _s;
}
inline const std::string& CheckResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void CheckResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CheckResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CheckResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:taxprro.CheckResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CheckResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.CheckResponse.error_message)
}

// -------------------------------------------------------------------

// StatusResponse

// bool open_shift = 1;
inline void StatusResponse::clear_open_shift() {
  open_shift_ = false;
}
inline bool StatusResponse::_internal_open_shift() const {
  return open_shift_;
}
inline bool StatusResponse::open_shift() const {
  // @@protoc_insertion_point(field_get:taxprro.StatusResponse.open_shift)
  return _internal_open_shift();
}
inline void StatusResponse::_internal_set_open_shift(bool value) {
  
  open_shift_ = value;
}
inline void StatusResponse::set_open_shift(bool value) {
  _internal_set_open_shift(value);
  // @@protoc_insertion_point(field_set:taxprro.StatusResponse.open_shift)
}

// bool online = 2;
inline void StatusResponse::clear_online() {
  online_ = false;
}
inline bool StatusResponse::_internal_online() const {
  return online_;
}
inline bool StatusResponse::online() const {
  // @@protoc_insertion_point(field_get:taxprro.StatusResponse.online)
  return _internal_online();
}
inline void StatusResponse::_internal_set_online(bool value) {
  
  online_ = value;
}
inline void StatusResponse::set_online(bool value) {
  _internal_set_online(value);
  // @@protoc_insertion_point(field_set:taxprro.StatusResponse.online)
}

// string last_signer = 3;
inline void StatusResponse::clear_last_signer() {
  last_signer_.ClearToEmpty();
}
inline const std::string& StatusResponse::last_signer() const {
  // @@protoc_insertion_point(field_get:taxprro.StatusResponse.last_signer)
  return _internal_last_signer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusResponse::set_last_signer(ArgT0&& arg0, ArgT... args) {
 
 last_signer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.StatusResponse.last_signer)
}
inline std::string* StatusResponse::mutable_last_signer() {
  std::string* _s = _internal_mutable_last_signer();
  // @@protoc_insertion_point(field_mutable:taxprro.StatusResponse.last_signer)
  return _s;
}
inline const std::string& StatusResponse::_internal_last_signer() const {
  return last_signer_.Get();
}
inline void StatusResponse::_internal_set_last_signer(const std::string& value) {
  
  last_signer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StatusResponse::_internal_mutable_last_signer() {
  
  return last_signer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StatusResponse::release_last_signer() {
  // @@protoc_insertion_point(field_release:taxprro.StatusResponse.last_signer)
  return last_signer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StatusResponse::set_allocated_last_signer(std::string* last_signer) {
  if (last_signer != nullptr) {
    
  } else {
    
  }
  last_signer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_signer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.StatusResponse.last_signer)
}

// .taxprro.StatusResponse.Status status = 4;
inline void StatusResponse::clear_status() {
  status_ = 0;
}
inline ::taxprro::StatusResponse_Status StatusResponse::_internal_status() const {
  return static_cast< ::taxprro::StatusResponse_Status >(status_);
}
inline ::taxprro::StatusResponse_Status StatusResponse::status() const {
  // @@protoc_insertion_point(field_get:taxprro.StatusResponse.status)
  return _internal_status();
}
inline void StatusResponse::_internal_set_status(::taxprro::StatusResponse_Status value) {
  
  status_ = value;
}
inline void StatusResponse::set_status(::taxprro::StatusResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:taxprro.StatusResponse.status)
}

// string error_message = 5;
inline void StatusResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& StatusResponse::error_message() const {
  // @@protoc_insertion_point(field_get:taxprro.StatusResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.StatusResponse.error_message)
}
inline std::string* StatusResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:taxprro.StatusResponse.error_message)
  return _s;
}
inline const std::string& StatusResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void StatusResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StatusResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StatusResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:taxprro.StatusResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StatusResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.StatusResponse.error_message)
}

// -------------------------------------------------------------------

// RroInfoResponse_Operator

// string serial = 1;
inline void RroInfoResponse_Operator::clear_serial() {
  serial_.ClearToEmpty();
}
inline const std::string& RroInfoResponse_Operator::serial() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.Operator.serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RroInfoResponse_Operator::set_serial(ArgT0&& arg0, ArgT... args) {
 
 serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.Operator.serial)
}
inline std::string* RroInfoResponse_Operator::mutable_serial() {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:taxprro.RroInfoResponse.Operator.serial)
  return _s;
}
inline const std::string& RroInfoResponse_Operator::_internal_serial() const {
  return serial_.Get();
}
inline void RroInfoResponse_Operator::_internal_set_serial(const std::string& value) {
  
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RroInfoResponse_Operator::_internal_mutable_serial() {
  
  return serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RroInfoResponse_Operator::release_serial() {
  // @@protoc_insertion_point(field_release:taxprro.RroInfoResponse.Operator.serial)
  return serial_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RroInfoResponse_Operator::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    
  } else {
    
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.RroInfoResponse.Operator.serial)
}

// int32 status = 2;
inline void RroInfoResponse_Operator::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RroInfoResponse_Operator::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RroInfoResponse_Operator::status() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.Operator.status)
  return _internal_status();
}
inline void RroInfoResponse_Operator::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void RroInfoResponse_Operator::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.Operator.status)
}

// bool senior = 3;
inline void RroInfoResponse_Operator::clear_senior() {
  senior_ = false;
}
inline bool RroInfoResponse_Operator::_internal_senior() const {
  return senior_;
}
inline bool RroInfoResponse_Operator::senior() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.Operator.senior)
  return _internal_senior();
}
inline void RroInfoResponse_Operator::_internal_set_senior(bool value) {
  
  senior_ = value;
}
inline void RroInfoResponse_Operator::set_senior(bool value) {
  _internal_set_senior(value);
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.Operator.senior)
}

// string isname = 4;
inline void RroInfoResponse_Operator::clear_isname() {
  isname_.ClearToEmpty();
}
inline const std::string& RroInfoResponse_Operator::isname() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.Operator.isname)
  return _internal_isname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RroInfoResponse_Operator::set_isname(ArgT0&& arg0, ArgT... args) {
 
 isname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.Operator.isname)
}
inline std::string* RroInfoResponse_Operator::mutable_isname() {
  std::string* _s = _internal_mutable_isname();
  // @@protoc_insertion_point(field_mutable:taxprro.RroInfoResponse.Operator.isname)
  return _s;
}
inline const std::string& RroInfoResponse_Operator::_internal_isname() const {
  return isname_.Get();
}
inline void RroInfoResponse_Operator::_internal_set_isname(const std::string& value) {
  
  isname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RroInfoResponse_Operator::_internal_mutable_isname() {
  
  return isname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RroInfoResponse_Operator::release_isname() {
  // @@protoc_insertion_point(field_release:taxprro.RroInfoResponse.Operator.isname)
  return isname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RroInfoResponse_Operator::set_allocated_isname(std::string* isname) {
  if (isname != nullptr) {
    
  } else {
    
  }
  isname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), isname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.RroInfoResponse.Operator.isname)
}

// -------------------------------------------------------------------

// RroInfoResponse

// .taxprro.RroInfoResponse.Status status = 1;
inline void RroInfoResponse::clear_status() {
  status_ = 0;
}
inline ::taxprro::RroInfoResponse_Status RroInfoResponse::_internal_status() const {
  return static_cast< ::taxprro::RroInfoResponse_Status >(status_);
}
inline ::taxprro::RroInfoResponse_Status RroInfoResponse::status() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.status)
  return _internal_status();
}
inline void RroInfoResponse::_internal_set_status(::taxprro::RroInfoResponse_Status value) {
  
  status_ = value;
}
inline void RroInfoResponse::set_status(::taxprro::RroInfoResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.status)
}

// int32 status_rro = 2;
inline void RroInfoResponse::clear_status_rro() {
  status_rro_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RroInfoResponse::_internal_status_rro() const {
  return status_rro_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RroInfoResponse::status_rro() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.status_rro)
  return _internal_status_rro();
}
inline void RroInfoResponse::_internal_set_status_rro(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_rro_ = value;
}
inline void RroInfoResponse::set_status_rro(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status_rro(value);
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.status_rro)
}

// bool open_shift = 3;
inline void RroInfoResponse::clear_open_shift() {
  open_shift_ = false;
}
inline bool RroInfoResponse::_internal_open_shift() const {
  return open_shift_;
}
inline bool RroInfoResponse::open_shift() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.open_shift)
  return _internal_open_shift();
}
inline void RroInfoResponse::_internal_set_open_shift(bool value) {
  
  open_shift_ = value;
}
inline void RroInfoResponse::set_open_shift(bool value) {
  _internal_set_open_shift(value);
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.open_shift)
}

// bool online = 4;
inline void RroInfoResponse::clear_online() {
  online_ = false;
}
inline bool RroInfoResponse::_internal_online() const {
  return online_;
}
inline bool RroInfoResponse::online() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.online)
  return _internal_online();
}
inline void RroInfoResponse::_internal_set_online(bool value) {
  
  online_ = value;
}
inline void RroInfoResponse::set_online(bool value) {
  _internal_set_online(value);
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.online)
}

// string last_signer = 5;
inline void RroInfoResponse::clear_last_signer() {
  last_signer_.ClearToEmpty();
}
inline const std::string& RroInfoResponse::last_signer() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.last_signer)
  return _internal_last_signer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RroInfoResponse::set_last_signer(ArgT0&& arg0, ArgT... args) {
 
 last_signer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.last_signer)
}
inline std::string* RroInfoResponse::mutable_last_signer() {
  std::string* _s = _internal_mutable_last_signer();
  // @@protoc_insertion_point(field_mutable:taxprro.RroInfoResponse.last_signer)
  return _s;
}
inline const std::string& RroInfoResponse::_internal_last_signer() const {
  return last_signer_.Get();
}
inline void RroInfoResponse::_internal_set_last_signer(const std::string& value) {
  
  last_signer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::_internal_mutable_last_signer() {
  
  return last_signer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::release_last_signer() {
  // @@protoc_insertion_point(field_release:taxprro.RroInfoResponse.last_signer)
  return last_signer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RroInfoResponse::set_allocated_last_signer(std::string* last_signer) {
  if (last_signer != nullptr) {
    
  } else {
    
  }
  last_signer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_signer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.RroInfoResponse.last_signer)
}

// string name = 6;
inline void RroInfoResponse::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RroInfoResponse::name() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RroInfoResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.name)
}
inline std::string* RroInfoResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:taxprro.RroInfoResponse.name)
  return _s;
}
inline const std::string& RroInfoResponse::_internal_name() const {
  return name_.Get();
}
inline void RroInfoResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::release_name() {
  // @@protoc_insertion_point(field_release:taxprro.RroInfoResponse.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RroInfoResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.RroInfoResponse.name)
}

// string name_to = 7;
inline void RroInfoResponse::clear_name_to() {
  name_to_.ClearToEmpty();
}
inline const std::string& RroInfoResponse::name_to() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.name_to)
  return _internal_name_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RroInfoResponse::set_name_to(ArgT0&& arg0, ArgT... args) {
 
 name_to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.name_to)
}
inline std::string* RroInfoResponse::mutable_name_to() {
  std::string* _s = _internal_mutable_name_to();
  // @@protoc_insertion_point(field_mutable:taxprro.RroInfoResponse.name_to)
  return _s;
}
inline const std::string& RroInfoResponse::_internal_name_to() const {
  return name_to_.Get();
}
inline void RroInfoResponse::_internal_set_name_to(const std::string& value) {
  
  name_to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::_internal_mutable_name_to() {
  
  return name_to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::release_name_to() {
  // @@protoc_insertion_point(field_release:taxprro.RroInfoResponse.name_to)
  return name_to_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RroInfoResponse::set_allocated_name_to(std::string* name_to) {
  if (name_to != nullptr) {
    
  } else {
    
  }
  name_to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name_to,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.RroInfoResponse.name_to)
}

// string addr = 8;
inline void RroInfoResponse::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& RroInfoResponse::addr() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RroInfoResponse::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.addr)
}
inline std::string* RroInfoResponse::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:taxprro.RroInfoResponse.addr)
  return _s;
}
inline const std::string& RroInfoResponse::_internal_addr() const {
  return addr_.Get();
}
inline void RroInfoResponse::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::release_addr() {
  // @@protoc_insertion_point(field_release:taxprro.RroInfoResponse.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RroInfoResponse::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.RroInfoResponse.addr)
}

// bool single_tax = 9;
inline void RroInfoResponse::clear_single_tax() {
  single_tax_ = false;
}
inline bool RroInfoResponse::_internal_single_tax() const {
  return single_tax_;
}
inline bool RroInfoResponse::single_tax() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.single_tax)
  return _internal_single_tax();
}
inline void RroInfoResponse::_internal_set_single_tax(bool value) {
  
  single_tax_ = value;
}
inline void RroInfoResponse::set_single_tax(bool value) {
  _internal_set_single_tax(value);
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.single_tax)
}

// bool offline_allowed = 10;
inline void RroInfoResponse::clear_offline_allowed() {
  offline_allowed_ = false;
}
inline bool RroInfoResponse::_internal_offline_allowed() const {
  return offline_allowed_;
}
inline bool RroInfoResponse::offline_allowed() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.offline_allowed)
  return _internal_offline_allowed();
}
inline void RroInfoResponse::_internal_set_offline_allowed(bool value) {
  
  offline_allowed_ = value;
}
inline void RroInfoResponse::set_offline_allowed(bool value) {
  _internal_set_offline_allowed(value);
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.offline_allowed)
}

// int32 add_num = 11;
inline void RroInfoResponse::clear_add_num() {
  add_num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RroInfoResponse::_internal_add_num() const {
  return add_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RroInfoResponse::add_num() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.add_num)
  return _internal_add_num();
}
inline void RroInfoResponse::_internal_set_add_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  add_num_ = value;
}
inline void RroInfoResponse::set_add_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_add_num(value);
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.add_num)
}

// string pn = 12;
inline void RroInfoResponse::clear_pn() {
  pn_.ClearToEmpty();
}
inline const std::string& RroInfoResponse::pn() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.pn)
  return _internal_pn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RroInfoResponse::set_pn(ArgT0&& arg0, ArgT... args) {
 
 pn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.pn)
}
inline std::string* RroInfoResponse::mutable_pn() {
  std::string* _s = _internal_mutable_pn();
  // @@protoc_insertion_point(field_mutable:taxprro.RroInfoResponse.pn)
  return _s;
}
inline const std::string& RroInfoResponse::_internal_pn() const {
  return pn_.Get();
}
inline void RroInfoResponse::_internal_set_pn(const std::string& value) {
  
  pn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::_internal_mutable_pn() {
  
  return pn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::release_pn() {
  // @@protoc_insertion_point(field_release:taxprro.RroInfoResponse.pn)
  return pn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RroInfoResponse::set_allocated_pn(std::string* pn) {
  if (pn != nullptr) {
    
  } else {
    
  }
  pn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pn,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.RroInfoResponse.pn)
}

// repeated .taxprro.RroInfoResponse.Operator operators = 13;
inline int RroInfoResponse::_internal_operators_size() const {
  return operators_.size();
}
inline int RroInfoResponse::operators_size() const {
  return _internal_operators_size();
}
inline void RroInfoResponse::clear_operators() {
  operators_.Clear();
}
inline ::taxprro::RroInfoResponse_Operator* RroInfoResponse::mutable_operators(int index) {
  // @@protoc_insertion_point(field_mutable:taxprro.RroInfoResponse.operators)
  return operators_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::taxprro::RroInfoResponse_Operator >*
RroInfoResponse::mutable_operators() {
  // @@protoc_insertion_point(field_mutable_list:taxprro.RroInfoResponse.operators)
  return &operators_;
}
inline const ::taxprro::RroInfoResponse_Operator& RroInfoResponse::_internal_operators(int index) const {
  return operators_.Get(index);
}
inline const ::taxprro::RroInfoResponse_Operator& RroInfoResponse::operators(int index) const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.operators)
  return _internal_operators(index);
}
inline ::taxprro::RroInfoResponse_Operator* RroInfoResponse::_internal_add_operators() {
  return operators_.Add();
}
inline ::taxprro::RroInfoResponse_Operator* RroInfoResponse::add_operators() {
  ::taxprro::RroInfoResponse_Operator* _add = _internal_add_operators();
  // @@protoc_insertion_point(field_add:taxprro.RroInfoResponse.operators)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::taxprro::RroInfoResponse_Operator >&
RroInfoResponse::operators() const {
  // @@protoc_insertion_point(field_list:taxprro.RroInfoResponse.operators)
  return operators_;
}

// string tins = 14;
inline void RroInfoResponse::clear_tins() {
  tins_.ClearToEmpty();
}
inline const std::string& RroInfoResponse::tins() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.tins)
  return _internal_tins();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RroInfoResponse::set_tins(ArgT0&& arg0, ArgT... args) {
 
 tins_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.tins)
}
inline std::string* RroInfoResponse::mutable_tins() {
  std::string* _s = _internal_mutable_tins();
  // @@protoc_insertion_point(field_mutable:taxprro.RroInfoResponse.tins)
  return _s;
}
inline const std::string& RroInfoResponse::_internal_tins() const {
  return tins_.Get();
}
inline void RroInfoResponse::_internal_set_tins(const std::string& value) {
  
  tins_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::_internal_mutable_tins() {
  
  return tins_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::release_tins() {
  // @@protoc_insertion_point(field_release:taxprro.RroInfoResponse.tins)
  return tins_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RroInfoResponse::set_allocated_tins(std::string* tins) {
  if (tins != nullptr) {
    
  } else {
    
  }
  tins_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tins,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.RroInfoResponse.tins)
}

// int32 lnum = 15;
inline void RroInfoResponse::clear_lnum() {
  lnum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RroInfoResponse::_internal_lnum() const {
  return lnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RroInfoResponse::lnum() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.lnum)
  return _internal_lnum();
}
inline void RroInfoResponse::_internal_set_lnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lnum_ = value;
}
inline void RroInfoResponse::set_lnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lnum(value);
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.lnum)
}

// string name_pay = 16;
inline void RroInfoResponse::clear_name_pay() {
  name_pay_.ClearToEmpty();
}
inline const std::string& RroInfoResponse::name_pay() const {
  // @@protoc_insertion_point(field_get:taxprro.RroInfoResponse.name_pay)
  return _internal_name_pay();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RroInfoResponse::set_name_pay(ArgT0&& arg0, ArgT... args) {
 
 name_pay_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taxprro.RroInfoResponse.name_pay)
}
inline std::string* RroInfoResponse::mutable_name_pay() {
  std::string* _s = _internal_mutable_name_pay();
  // @@protoc_insertion_point(field_mutable:taxprro.RroInfoResponse.name_pay)
  return _s;
}
inline const std::string& RroInfoResponse::_internal_name_pay() const {
  return name_pay_.Get();
}
inline void RroInfoResponse::_internal_set_name_pay(const std::string& value) {
  
  name_pay_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::_internal_mutable_name_pay() {
  
  return name_pay_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RroInfoResponse::release_name_pay() {
  // @@protoc_insertion_point(field_release:taxprro.RroInfoResponse.name_pay)
  return name_pay_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RroInfoResponse::set_allocated_name_pay(std::string* name_pay) {
  if (name_pay != nullptr) {
    
  } else {
    
  }
  name_pay_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name_pay,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:taxprro.RroInfoResponse.name_pay)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace taxprro

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::taxprro::Check_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::taxprro::Check_Type>() {
  return ::taxprro::Check_Type_descriptor();
}
template <> struct is_proto_enum< ::taxprro::CheckResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::taxprro::CheckResponse_Status>() {
  return ::taxprro::CheckResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::taxprro::StatusResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::taxprro::StatusResponse_Status>() {
  return ::taxprro::StatusResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::taxprro::RroInfoResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::taxprro::RroInfoResponse_Status>() {
  return ::taxprro::RroInfoResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tax_2eproto
